# Exercise - JPA Entity Mappings – 2
*These exercises are meant to assist you in learning important ORM-topics. The task is not to complete the exercises as fast as possible, but to LEARN important concepts. Don’t skip parts like :  “Make sure you understand ..”, “explain why ..” etc. These parts match typical questions given at the exam.
*

### Relationship Mapping
Object oriented programming is, to a large degree, about creating classes which relate to each other. If a class cannot solve a problem by itself, it delegates the job to another class. 
Relations between classes have **cardinality**, and can be either *bi- or uni-directional.*
There are 8 different combinations of Cardinality and Direction, and they can all easily be implemented in JPA with some nice NetBeans-assistance.

| Cardinality  | Direction |
| ------------- | ------------- |
| One-to-one  | Unidirectional  |
| One-to-one  | Bidirectional  |
| One-to-many | Unidirectional |
| Many-to-one one-to-many | Bidirectional |
| Many-to-one | Unidirectional |
| Many-to-one | Unidirectional |
| Many-to-one | Bidirectional |

In the following, we will test four of these combinations 

### Getting Started

For this exercise you need two Entity classes as sketched below:

`Customer`	→ With the fields `id(Integer), firstName(String), lastName(String)`  
`Address`	→ With the fields `id (Integer), street (String), city (String)`

For both classes, use `GenerationType.IDENTITY` to let the database generate ids automatically (using MySQLs `AUTO_INCREMENT` feature)
Create a new plain java maven project (or continue with the project from day-1), and use the netbeans-wizard to add the two entity classes + relevant getters, setters and constructors (don't forget the zero-arg constructor. 
Add a Tester-class, similar to day-1, and this line to verify that we can create the matching classes:
`Persistence.generateSchema("NAME_OF YOUR_PU", null);`

*Note: The following exercises is just as much a recap on your second-semester knowledge about relational mappings. DON’t skip the steps, where you are requested to compare Entity Classes to the generated tables. This is to a large degree what what we will discuss at the examination.*

### One to One – Unidirectional

Provider the Customer with an Address field:

`private Address address;`

Add the cursor on the field and press ALT + ENTER → Select `Create unidirectional one to one relationship`  
Make sure you understand the "things" that changed in the `Customer` and (if any) the `Address class`.

Regenerate the schema and investigate the generated tables. Observe the location of the foreign key.

*Before you continue, make sure you understand (100% exam relevant) how and OO-language implements OneToOne relations and how a relational database do the same.*

### One to One – Bidirectional

Remove the `@OneToOne` annotation and create a bidirectional one to one relationship (again - right-click, and select the option you want).

Make sure you understand what is meant by bidirectional, before you continue (how would you show bidirectional using UML?)

Creating a bidirectional relationship will obviously require you to add a reference in Address, pointing back to Customer. Provide a name when requested by the wizard (customer) and select the default for the owning side.

* Go to the Address` class. Investigate and understand the generated code.
* Run the project and investigate the generated tables (the foreign key). Is there any difference compared to the previous exercise. If not explain why.

*Note: The owning side of the relation is the side of the relation that owns the foreign key in the database*

### One to Many - Unidirectional

Remove the generated code in both classes and use the wizard, one more time.  This time to generate a `OneToMany` relationship. You obviously can’t do that with your current Address field since this can hold only one instance, so change it into:

`private List<Address> addresses = new ArrayList();`

Now, a `Customer` can have several addresses. If you feel the opposite makes more sense; an address can have more Customers (i.e two customers are married, and live together), just do that instead, this is a “business decision”.

Now, use the wizard to generate a `OneToMany` Unidirectional relationship.

* Observe the generated code.
* Run the project and investigate the generated tables. Make sure to press Refresh so see all tables. 
* How many tables were generated? Explain the purpose of each of the tables.
* If you (as me) don't like the number of generated tables generated by this strategy, you can use the @JoinColumn annotation to implement the relation using a foreign key. Do this, but before you test, delete ALL generated tables in the database
* Create a "test" method and insert a number of Customers with Addresses into the tables, using JPA.


